#' Compute Q and clever covariates per id using a discrete-state backward recursion
#'
#' The function expects a time-ordered `dt_id` (rows for a single id) that
#' contains hazard columns named like `P.<name>.<s>` for each discovered
#' process `<name>` and state index `s` in `1..S`. It uses the product-space
#' `states` table to map state indices and to build successor mappings.
#'
#' @param dt_id data.table with time-ordered rows for a single id. Must contain columns for hazards of the form P.<name>.<s>.
#' @param states data.table enumerating the product state space. Must have S rows and columns for each stateful process (named by process) plus a column `state` giving indices 1..S.
#' @param process.types named character vector or list describing each discovered process type. Allowed values include: "terminal", "recurrent", "one.jump", "state-with-atrisk". If omitted, a small heuristic is used.
#' @param P.prefix prefix used for hazard columns in dt_id (default "P."). The function looks for columns matching `^P.prefix<name>.<s>$`.
#' @param state.idx.col name of the column in dt_id that holds the state index (value in 1..S). Default "state".
#' @param parameter character: name of the target process/outcome. If "target" (default), the first discovered terminal/outcome name is used.
#' @param process.deltas optional numeric vector (length = number of discovered processes). Not used internally for mapping, only validated if provided.
#' @param compute.clever logical; whether to compute and append clever.Q.<name>0 / clever.Q.<name>1 (default TRUE).
#' @return data.table: `dt_id` augmented with column `Q` and columns `clever.Q.<name>0` and `clever.Q.<name>1` for each discovered name.
#' @examples
#' # compute.Q.clever.per.id(dt_id = some_dt_for_one_id, states = depend.matrix, process.types = process.types)
#' @export
#' 
compute.Q.clever.per.id <- function(dt_id,
                                    states,
                                    process.types = NULL,
                                    P.prefix = "P.",
                                    state.idx.col = "state",
                                    parameter = "target",
                                    process.deltas = NULL,
                                    compute.clever = TRUE,
                                    browse = FALSE) {

    requireNamespace("data.table")
    # Defensive checks & normalization
    if (is.null(states) || nrow(states) == 0) {
        states <- data.table::data.table(state = 1L)
    }
    S <- nrow(states)
    if (S < 1) stop("'states' must have at least one row")

    Tn <- nrow(dt_id)
    if (Tn < 1) stop("dt_id must have at least one row (time-ordered)")

    # state columns (exclude 'at.risk' and the state index)
    state_cols_all <- setdiff(names(states), c("at.risk", state.idx.col))
    state_processes <- state_cols_all

    # If the declared target is recurrent but not in states, ensure loops still consider it
    if (!is.null(process.types) && !is.null(parameter) &&
        parameter %in% names(process.types) &&
        identical(process.types[[parameter]], "recurrent") &&
        !(parameter %in% state_processes)) {
        state_processes <- c(parameter, state_processes)
    }
    # Track which processes actually have columns in 'states'
    stateful_in_states <- intersect(state_processes, state_cols_all)

    # Parse hazard columns in dt_id
    pcols <- grep(paste0("^", P.prefix, "[^\\.]+\\.[0-9]+$"), names(dt_id), value = TRUE)
    if (length(pcols) == 0L) {
        warning("No hazard columns found with prefix '", P.prefix, "'. Returning Q=0")
        out <- data.table::copy(dt_id)
        out[, Q := 0]
        return(out[])
    }
    re <- paste0("^", P.prefix, "([^\\.]+)\\.(\\d+)$")
    regs <- regmatches(pcols, regexec(re, pcols))
    found_names <- unique(vapply(regs, function(x) if (length(x) >= 3) x[2] else NA_character_, FUN.VALUE=""))
    found_names <- found_names[!is.na(found_names)]
    if (length(found_names) == 0L) stop("No hazard columns matched the expected pattern '", P.prefix, "<name>.<s>'")

    # Build columns_by_name and hazard matrices (Tn x S)
    columns_by_name <- setNames(lapply(found_names, function(x) rep(NA_character_, S)), found_names)
    for (i in seq_along(pcols)) {
        r <- regs[[i]]
        if (length(r) < 3) next
        nm <- r[2]; sidx <- as.integer(r[3])
        if (is.na(sidx) || sidx < 1L || sidx > S) next
        columns_by_name[[nm]][sidx] <- pcols[i]
    }
    hazard_mats <- list()
    for (nm in found_names) {
        mat <- matrix(0, nrow = Tn, ncol = S)
        for (s in seq_len(S)) {
            colname <- columns_by_name[[nm]][s]
            if (!is.na(colname) && colname %in% names(dt_id)) mat[, s] <- as.numeric(dt_id[[colname]])
        }
        hazard_mats[[nm]] <- mat
    }

    # Partition discovered names into stateful (those in state_processes) and terminal (the rest)
    stateful_names <- intersect(found_names, state_processes)
    terminal_names  <- setdiff(found_names, stateful_names)
    # Optionally restrict terminal_names to those declared terminal in process.types
    if (!is.null(process.types)) {
        declared_terminal <- names(process.types)[sapply(process.types, function(x) identical(x, "terminal"))]
        if (length(declared_terminal) > 0L) terminal_names <- intersect(terminal_names, declared_terminal)
    }
    stateful_names <- sort(stateful_names)
    terminal_names <- sort(terminal_names)

    # ---- build successor mappings
    # For the actual state columns (stateful_in_states) compute proc_caps and key vectors
    if (length(stateful_in_states) > 0L) {
        proc_caps <- integer(length(stateful_in_states))
        for (j in seq_along(stateful_in_states)) {
            vals <- as.integer(states[[ stateful_in_states[j] ]])
            proc_caps[j] <- max(vals, na.rm = TRUE)
        }
        key_vec_real <- do.call(paste, c(lapply(states[, ..stateful_in_states], as.character), sep = ","))
        state_lookup_real <- setNames(states[[ state.idx.col ]], key_vec_real)
    } else {
        proc_caps <- integer(0)
        key_vec_real <- as.character(states[[ state.idx.col ]])
        state_lookup_real <- setNames(states[[ state.idx.col ]], key_vec_real)
    }

    # Stay mapping: maps row -> state index
    gamma_stay_idx <- states[[ state.idx.col ]]

    # Build gamma_jump_idx aligned with state_processes
    M_proc_all <- length(state_processes)
    gamma_jump_idx <- vector("list", M_proc_all)
    for (j_all in seq_len(M_proc_all)) {
        procj_name <- state_processes[j_all]
        if (procj_name %in% stateful_in_states) {
            j_in <- which(stateful_in_states == procj_name)
            gamma_jump_idx[[j_all]] <- integer(S)
            for (s in seq_len(S)) {
                parts <- as.integer(strsplit(key_vec_real[s], ",")[[1]])
                parts[j_in] <- pmin(parts[j_in] + 1L, proc_caps[j_in])
                nk <- paste(parts, collapse = ",")
                if (is.null(state_lookup_real[[nk]])) stop("gamma mapping error: successor key not found: ", nk)
                gamma_jump_idx[[j_all]][s] <- as.integer(state_lookup_real[[nk]])
            }
        } else {
            # process not represented in states -> identity successor mapping
            gamma_jump_idx[[j_all]] <- seq_len(S)
        }
    }

    # ---- classify target
    target_name <- parameter
    if (identical(parameter, "target")) {
        # choose default: first terminal found, else first found name
        if (length(terminal_names) > 0L) target_name <- terminal_names[1L] else target_name <- found_names[1L]
    }
    if (!(target_name %in% c(found_names, state_processes))) {
        stop("parameter must be one of discovered names or a recurrent target declared. Found: ", paste(c(found_names, state_processes), collapse = ", "))
    }
    target_in_states <- target_name %in% stateful_in_states
    if (!is.null(process.types) && target_name %in% names(process.types)) {
        target_type <- process.types[[target_name]]
    } else {
        target_type <- if (target_name %in% terminal_names) "terminal" else if (target_name %in% stateful_in_states) "recurrent" else "one.jump"
    }
    target_one_jump <- identical(target_type, "one.jump")
    target_terminal <- identical(target_type, "terminal")
    target_recurrent <- identical(target_type, "recurrent")
    target_with_atrisk <- identical(target_type, "state-with-atrisk")
    target_terminal_or_recurrent <- target_terminal | target_recurrent
    target_name_in_states <- target_name %in% names(states)

    is_recurrent_state_processes <-
        target_recurrent*(state_processes == target_name)

    target_can_jump_from_state <- function(s) {
        if (target_with_atrisk && ("at.risk" %in% names(states))) {
            isTRUE(states$at.risk[s])
        } else TRUE
    }

    # ---- backward recursion
    Q_by_time <- vector("list", Tn)
    # terminal condition at last row: use hazard if present or zero
    if (target_name %in% names(hazard_mats)) {
        Q_T <- hazard_mats[[ target_name ]][Tn, ]
    } else {
        Q_T <- rep(0, S)
    }
    if (target_one_jump && target_name_in_states) {
        Q_T[ as.integer(states[[ target_name ]]) >= 1 ] <- 1
    }
    Q_by_time[[Tn]] <- Q_T

    ## ---------- Precompute hazard sums (one-time, outside tt-loop)
    if (length(terminal_names) > 0L) {
        Pout_sum_mat <- Reduce(`+`, lapply(terminal_names, function(nm) hazard_mats[[nm]]),
                               init = matrix(0, nrow = Tn, ncol = S))
    } else {
        Pout_sum_mat <- matrix(0, nrow = Tn, ncol = S)
    }
    if (length(stateful_names) > 0L) {
        Pproc_sum_mat <- Reduce(`+`, lapply(stateful_names, function(nm) hazard_mats[[nm]]),
                                init = matrix(0, nrow = Tn, ncol = S))
    } else {
        Pproc_sum_mat <- matrix(0, nrow = Tn, ncol = S)
    }

    zeroS <- rep(0, S)

    M <- length(state_processes)
    hazard_arr <- array(0, dim = c(Tn, S, M))
    
    for (j in seq_along(state_processes)) {
        nm <- state_processes[j]
        if (nm %in% names(hazard_mats)) {
            hazard_arr[,,j] <- hazard_mats[[nm]]   # matrix (Tn x S)
        } else {
            hazard_arr[,,j] <- matrix(0, nrow = Tn, ncol = S) # cheap once
        }
    }

    Q_mat <- matrix(0, nrow = Tn, ncol = S)
    Q_mat[Tn, ] <- Q_T

    gamma_jump_idx_mat <- matrix(NA_integer_, nrow = S, ncol = M)
    for (j in seq_len(M)) gamma_jump_idx_mat[, j] <- gamma_jump_idx[[j]]
    
    if (browse) browser()

    for (tt in (Tn - 1):1) {
        Qn <- Q_mat[tt+1,]

        Pout_sum <- Pout_sum_mat[tt, ]
        Pproc_sum <- Pproc_sum_mat[tt, ]

        Pstay <- 1 - Pout_sum - Pproc_sum

        Qt <- Pstay * Qn[ gamma_stay_idx ]

        P_states <- hazard_arr[tt, ,]

        Qn_jump_mat <- matrix(Qn[gamma_jump_idx_mat], nrow = S, ncol = M) 

        Qt <- Qt + rowSums(P_states * Qn_jump_mat)
        
        # add immediate reward for terminal and recurrent targets
        if (target_terminal_or_recurrent) {
            Qt <- Qt + hazard_mats[[ target_name ]][tt, ]
        }

        # enforce one-jump terminal states -> Q=1 where already observed
        if (target_one_jump && target_name_in_states) {
            already_idx <- which(as.integer(states[[ target_name ]]) >= 1)
            if (length(already_idx) > 0L) Qt[already_idx] <- 1
        }

        Q_mat[tt, ] <- Qt
    }

    # --- attach rowwise Q
    out <- data.table::copy(dt_id)
    Q_row <- numeric(Tn)

    if (compute.clever) {
        # ---------- clever covariates
        all_names <- sort(unique(c(state_processes, terminal_names)))
        clever0 <- matrix(NA_real_, nrow = Tn, ncol = length(all_names), dimnames = list(NULL, all_names))
        clever1 <- matrix(NA_real_, nrow = Tn, ncol = length(all_names), dimnames = list(NULL, all_names))
        if (target_name_in_states) {
            target_observed_by_state <- as.integer(states[[ target_name ]] >= 1)  # length S
        } else {
            target_observed_by_state <- integer(S)  # zeros
        }
    }

    s_vec <- as.integer(out[[ state.idx.col ]]) 
    
    for (tt in seq_len(Tn)) {
        s <- s_vec[tt]
        Q_row[tt] <- Q_mat[tt,s]
        
        if (target_name_in_states) {
            target_observed_by_state_s <- target_observed_by_state[s]
        } else {
            target_observed_by_state_s <- 0
        }

        if (compute.clever) {

            Qn <- if (tt < Tn) Q_mat[tt + 1,] else Q_mat[tt,]

            s_no <- gamma_stay_idx[s]
            clever0[tt, ] <- Qn[s_no]
            
            # terminal processes
            for (nm in terminal_names) {
                if (nm == target_name && target_terminal) {
                    clever1[tt, nm] <- 1
                } else {
                    clever1[tt, nm] <- target_observed_by_state_s
                }
            }

            succ_idx_vec <- gamma_jump_idx_mat[s, ]   # length M
            clever1_vals_stateful <- Qn[succ_idx_vec] # length M
            clever1[tt, state_processes] <- clever1_vals_stateful+is_recurrent_state_processes
            
        }

    }

    out[, Q := Q_row]

    if (compute.clever) {
        # attach clever columns
        for (nm in all_names) {
            out[[ paste0("clever.Q.", nm, "0") ]] <- clever0[, nm]
            out[[ paste0("clever.Q.", nm, "1") ]] <- clever1[, nm]
        }
    }
 
    return(out[])
}
